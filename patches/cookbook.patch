diff --git a/recipes/core/drivers-initfs/recipe.toml b/recipes/core/drivers-initfs/recipe.toml
index 7f35030d..b7c560b5 100644
--- a/recipes/core/drivers-initfs/recipe.toml
+++ b/recipes/core/drivers-initfs/recipe.toml
@@ -61,7 +61,7 @@ export CARGO_PROFILE_RELEASE_PANIC=abort
 for bin in "${BINS[@]}"
 do
     case "${bin}" in
-      pcid | fbcond | inputd | vesad | lived | ps2d | acpid)
+      pcid | fbcond | inputd | vesad | lived | ps2d | acpid | bcm2835-sdhcid)
         cp -v "target/${TARGET}/release/${bin}" "${COOKBOOK_STAGE}/bin"
         ;;
       *)
diff --git a/recipes/lmbench/recipe.toml b/recipes/lmbench/recipe.toml
new file mode 100644
index 00000000..f56972d3
--- /dev/null
+++ b/recipes/lmbench/recipe.toml
@@ -0,0 +1,2 @@
+[build]
+template = "cargo"
diff --git a/recipes/lmbench/source/Cargo.toml b/recipes/lmbench/source/Cargo.toml
new file mode 100644
index 00000000..3c89525e
--- /dev/null
+++ b/recipes/lmbench/source/Cargo.toml
@@ -0,0 +1,9 @@
+[package]
+name = "lmbench"
+version = "0.1.0"
+edition = "2021"
+
+[dependencies]
+libredox = "0.1.3"
+libc = "0.2"
+nix = "0.26"
\ No newline at end of file
diff --git a/recipes/lmbench/source/src/ctx.rs b/recipes/lmbench/source/src/ctx.rs
new file mode 100644
index 00000000..bd36eabd
--- /dev/null
+++ b/recipes/lmbench/source/src/ctx.rs
@@ -0,0 +1,107 @@
+//test context switch overhead
+use crate::*;
+
+use std::thread;
+const CTX_ITER: usize = ITERATIONS * 1000;
+/// Measures the time to switch between two kernel threads.
+/// Calls `do_ctx_inner` multiple times to perform the actual operation
+pub fn do_ctx() -> Result<(), &'static str> {
+    let mut tries: f64 = 0.0;
+    let mut max: f64 = core::f64::MIN;
+    let mut min: f64 = core::f64::MAX;
+    let mut vec: Vec<f64> = Vec::with_capacity(TRIES);
+    print_header(TRIES, CTX_ITER);
+
+    for i in 0..TRIES {
+        let lat = do_ctx_inner(i + 1, TRIES)?;
+
+        tries += lat;
+        vec.push(lat);
+
+        if lat > max {
+            max = lat;
+        }
+        if lat < min {
+            min = lat;
+        }
+    }
+
+    let lat = tries / TRIES as f64;
+
+    // We expect the maximum and minimum to be within 10*THRESHOLD_ERROR_RATIO % of the mean value
+    let err = (lat * 10.0 * THRESHOLD_ERROR_RATIO as f64) / 100.0;
+    if max - lat > err || lat - min > err {
+        printlnwarn!(
+            "ctx_test diff is too big: {:.3} ({:.3} - {:.3}) {}",
+            max - min,
+            max,
+            min,
+            T_UNIT
+        );
+    }
+    let stats = calculate_stats(&vec).ok_or("couldn't calculate stats")?;
+    printlninfo!("Context switch result: ({})", T_UNIT);
+    printlninfo!("{:?}", stats);
+    printlninfo!("This test does not have an equivalent test in LMBench");
+    Ok(())
+}
+
+fn do_ctx_inner(th: usize, nr: usize /*, child_core: u8 */) -> Result<f64, &'static str> {
+    let start_hpet = get_timer_value()?;
+    let end_hpet: f64;
+    let overhead_end_hpet: f64;
+
+    // Spawning "overhead" threads
+    let taskref1 = thread::spawn(overhead_task);
+    let taskref2 = thread::spawn(overhead_task);
+
+    // Waiting for "overhead" threads to complete
+    taskref1.join().expect("Task 1 failed");
+    taskref2.join().expect("Task 2 failed");
+
+    // Timer simulation for overhead tasks (replace with actual timer logic)
+    let overhead_end_hpet = get_timer_value()?;
+    println!("Overhead end HPET: {:?}", overhead_end_hpet);
+
+    // Spawning "yield" threads
+    let taskref3 = thread::spawn(yield_task);
+    let taskref4 = thread::spawn(yield_task);
+
+    // Waiting for "yield" threads to complete
+    taskref3.join().expect("Task 3 failed");
+    taskref4.join().expect("Task 4 failed");
+
+    end_hpet = get_timer_value()?;
+
+    let delta_overhead = overhead_end_hpet - start_hpet;
+    let delta_hpet = end_hpet - overhead_end_hpet - delta_overhead;
+    let delta_time_avg = delta_hpet / (CTX_ITER * 2) as f64; //*2 because each thread yields ITERATION number of times
+    printlninfo!(
+        "ctx_switch_test_inner ({}/{}): total_overhead -> {:.3} {} , {:.3} total_time -> {:.3} {}",
+        th,
+        nr,
+        delta_overhead,
+        T_UNIT,
+        delta_hpet,
+        delta_time_avg,
+        T_UNIT
+    );
+    Ok(delta_time_avg)
+}
+
+// 模拟 sys_yield 功能
+fn sys_yield() {
+    thread::yield_now();
+}
+
+// overhead 执行的函数
+fn overhead_task() {
+    println!("hello, this is overhead test");
+}
+
+// yield 执行的函数
+fn yield_task() {
+    for _ in 0..CTX_ITER {
+        sys_yield();
+    }
+}
diff --git a/recipes/lmbench/source/src/fs.rs b/recipes/lmbench/source/src/fs.rs
new file mode 100644
index 00000000..f3d503d2
--- /dev/null
+++ b/recipes/lmbench/source/src/fs.rs
@@ -0,0 +1,372 @@
+const FS_ITER: usize = ITERATIONS * 10;
+const WRITE_BUF_SIZE: usize = 1024 * 1024;
+const WRITE_BUF: [u8; WRITE_BUF_SIZE] = [65; WRITE_BUF_SIZE];
+const FILE_SIZE: usize = 4096;
+const MB: u64 = 1024 * 1024;
+const KB: u64 = 1024;
+const NANOSECOND: usize = 1_000_000_000;
+const MICROSECOND: usize = 1_000_000;
+use crate::*;
+use std::fs::{remove_file, File, OpenOptions};
+use std::io::{self, Read, Write};
+/// tests for fs
+pub fn do_fs_read(with_open: bool) -> Result<(), &'static str> {
+    let fsize_kb = 4;
+    printlninfo!("File size     : {} KB", fsize_kb);
+    printlninfo!("Read buf size : {} KB", FILE_SIZE);
+    printlninfo!("========================================");
+
+    //Used to measure the overhead of the timer
+    let overhead_ct = get_timing_overhead()?;
+
+    do_fs_read_with_size(overhead_ct, fsize_kb, with_open)?;
+    if with_open {
+        printlninfo!("This test is equivalent to `bw_file_rd open2close` in LMBench");
+    } else {
+        printlninfo!("This test is equivalent to `bw_file_rd io_only` in LMBench");
+    }
+    Ok(())
+}
+
+fn do_fs_read_with_size(
+    overhead_ct: f64,
+    fsize_kb: usize,
+    with_open: bool,
+) -> Result<(), &'static str> {
+    let mut tries: f64 = 0.0;
+    let mut tries_mb: f64 = 0.0;
+    let mut tries_kb: f64 = 0.0;
+    let mut max: f64 = core::f64::MIN;
+    let mut min: f64 = core::f64::MAX;
+    let fsize_b = fsize_kb * KB as usize;
+    let mut vec = Vec::new();
+
+    let filename = "tmp.txt\n".to_string(); // file size 4 KB.
+
+    // we can use `mk_tmp_file()` because it is outside of the loop
+    mk_tmp_file(&filename, fsize_b).expect("Cannot create a file");
+
+    for i in 0..TRIES {
+        let (lat, tput_mb, tput_kb) = if with_open {
+            do_fs_read_with_open_inner(&filename, overhead_ct, i + 1, TRIES, fsize_b)
+                .expect("Error in read_open inner()")
+        } else {
+            do_fs_read_only_inner(&filename, overhead_ct, i + 1, TRIES, fsize_b)
+                .expect("Error in read_only inner()")
+        };
+
+        tries += lat;
+        tries_mb += tput_mb;
+        tries_kb += tput_kb;
+        vec.push(tput_kb);
+
+        if lat > max {
+            max = lat;
+        }
+        if lat < min {
+            min = lat;
+        }
+    }
+    remove_file(filename).expect("Cannot delete a file");
+    let stats = calculate_stats(&vec).ok_or("couldn't calculate stats")?;
+
+    let lat = tries / TRIES as f64;
+    let tput_mb = tries_mb / TRIES as f64;
+    let tput_kb = tries_kb / TRIES as f64;
+    let err = (lat * 10.0 + lat * THRESHOLD_ERROR_RATIO as f64) / 10.0;
+    if max - lat > err || lat - min > err {
+        printlnwarn!(
+            "test diff is too big: {:.3} ({:.3} - {:.3}) {}",
+            max - min,
+            max,
+            min,
+            T_UNIT
+        );
+    }
+
+    print_header(TRIES, FS_ITER);
+    printlninfo!(
+        "{} for {:.3} KB: {:.3} {} {:.3} MB/sec {:.3} KB/sec",
+        if with_open {
+            "READ WITH OPEN"
+        } else {
+            "READ ONLY"
+        },
+        fsize_kb,
+        lat,
+        T_UNIT,
+        tput_mb,
+        tput_kb
+    );
+    printlninfo!("{:?}", stats);
+    Ok(())
+}
+
+fn do_fs_read_with_open_inner(
+    filename: &str,
+    overhead_ct: f64,
+    th: usize,
+    nr: usize,
+    fsize: usize,
+) -> Result<(f64, f64, f64), &'static str> {
+    let start_hpet: f64;
+    let end_hpet: f64;
+    let mut _dummy_sum: u64 = 0;
+
+    if fsize != FILE_SIZE {
+        return Err("File size is not alligned");
+    }
+
+    let mut buf = [0u8; FILE_SIZE];
+    start_hpet = get_timer_value()?;
+    let end_fd = 0;
+    for _ in 0..FS_ITER {
+        // 打开文件（读写模式，不存在则创建）
+        let mut file = OpenOptions::new()
+            .read(true)
+            .write(true)
+            .create(true)
+            .open(filename)
+            .unwrap();
+
+        // 读取文件
+        let read_size = file.read(&mut buf).unwrap();
+        _dummy_sum += read_size as u64;
+    }
+    end_hpet = get_timer_value()?;
+
+    let delta_hpet = end_hpet - start_hpet - overhead_ct;
+    let delta_time = delta_hpet;
+    let delta_time_avg = delta_time / FS_ITER as f64;
+
+    let mb_per_sec = (WRITE_BUF_SIZE * MICROSECOND) as f64 / (MB as f64 * delta_time_avg); // prefer this
+    let kb_per_sec = (WRITE_BUF_SIZE * MICROSECOND) as f64 / (KB as f64 * delta_time_avg);
+    // for i in end_fd - FS_ITER + 1..=end_fd {
+    //     sys_close(i as usize);
+    // }
+    printlninfo!(
+        "read_with_open_inner ({}/{}): {:.3} total_time -> {:.3} {} {:.3} MB/sec {:.3} KB/sec (ignore: {})",
+        th,
+        nr,
+        delta_time,
+        delta_time_avg,
+        T_UNIT,
+        mb_per_sec,
+        kb_per_sec,
+        _dummy_sum
+    );
+
+    Ok((delta_time_avg, mb_per_sec, kb_per_sec))
+}
+
+/// Internal function that actually calculates the time to read a file.
+/// This function read the file and sums up the read charachters in each chunk.
+/// This is performed to be compatible with `LMBench`
+fn do_fs_read_only_inner(
+    filename: &str,
+    overhead_ct: f64,
+    th: usize,
+    nr: usize,
+    fsize: usize,
+) -> Result<(f64, f64, f64), &'static str> {
+    let start_hpet: f64;
+    let end_hpet: f64;
+
+    let mut _dummy_sum: u64 = 0;
+    if fsize != FILE_SIZE {
+        return Err("File size is not alligned");
+    }
+    let mut buf = [0u8; FILE_SIZE];
+
+    let mut file = OpenOptions::new()
+        .read(true)
+        .write(true)
+        .create(true)
+        .open(filename)
+        .unwrap();
+
+    start_hpet = get_timer_value()?;
+    for _ in 0..FS_ITER {
+        // let nr_read = sys_read(fd as usize, &mut buf);
+        let nr_read = file.read(&mut buf).unwrap();
+        _dummy_sum += nr_read as u64;
+    }
+    end_hpet = get_timer_value()?;
+    drop(file);
+
+    let delta_hpet = end_hpet - start_hpet - overhead_ct;
+    let delta_time = delta_hpet;
+    println!("delete_time: {:.3} us", delta_time);
+    let delta_time_avg = delta_time / FS_ITER as f64;
+
+    println!("the delete_time_avg: {}", delta_time_avg);
+    let mb_per_sec = (WRITE_BUF_SIZE * MICROSECOND) as f64 / (MB as f64 * delta_time_avg); // prefer this
+    let kb_per_sec = (WRITE_BUF_SIZE * MICROSECOND) as f64 / (KB as f64 * delta_time_avg);
+
+    printlninfo!(
+        "read_only_inner ({}/{}): {:.3} total_time -> {:.3} {} {:.3} MB/sec {:.3} KB/sec (ignore: {})",
+        th,
+        nr,
+        delta_time,
+        delta_time_avg,
+        T_UNIT,
+        mb_per_sec,
+        kb_per_sec,
+        _dummy_sum
+    );
+
+    Ok((delta_time_avg, mb_per_sec, kb_per_sec))
+}
+
+fn mk_tmp_file(filename: &str, sz: usize) -> Result<(), &'static str> {
+    if sz > WRITE_BUF_SIZE {
+        return Err("Cannot test because the file size is too big");
+    } else if sz != FILE_SIZE {
+        return Err("Cannot test because the file size is not the same as the test file");
+    }
+
+    // create test file
+    let write_buf = [64u8; FILE_SIZE];
+    let mut file = OpenOptions::new()
+        .read(true)
+        .write(true)
+        .create(true)
+        .open(filename)
+        .unwrap();
+    file.write(&write_buf).expect("Cannot write to a file");
+    drop(file);
+
+    Ok(())
+}
+
+pub fn do_fs_create_del() -> Result<(), &'static str> {
+    let fsizes_b = [1024_usize, 4096, 8 * 1024];
+
+    let overhead_ct = get_timing_overhead()?;
+
+    print_header(TRIES, FS_ITER);
+    printlninfo!("SIZE(KB)    Iteration    created(files/s)     time(ns/file)");
+    for fsize_b in fsizes_b.iter() {
+        do_fs_create_del_inner(*fsize_b, overhead_ct)?;
+    }
+    printlninfo!("This test is equivalent to file create in `lat_fs` in LMBench");
+
+    Ok(())
+}
+
+fn do_fs_create_del_inner(fsize_b: usize, overhead_ct: f64) -> Result<(), &'static str> {
+    let start_hpet_create: f64;
+    let end_hpet_create: f64;
+    let create_iter = FS_ITER;
+
+    // check if we have enough data to write. We use just const data to avoid unnecessary overhead
+    if fsize_b > WRITE_BUF_SIZE {
+        return Err("Cannot test because the file size is too big");
+    }
+
+    let wbuf = &WRITE_BUF[0..fsize_b];
+
+    // Measuring loop - create
+    start_hpet_create = get_timer_value()?;
+
+    for i in 0..create_iter {
+        let filename = format!("tmp_{}_{}.txt", fsize_b, i);
+        let mut file = OpenOptions::new()
+            .read(true)
+            .write(true)
+            .create(true)
+            .open(filename)
+            .expect("Cannot create a file");
+        file.write(&wbuf).expect("Cannot write to a file");
+        drop(file);
+    }
+    end_hpet_create = get_timer_value()?;
+
+    let delta_hpet_create = end_hpet_create - start_hpet_create - overhead_ct;
+    let delta_time_create = delta_hpet_create;
+
+    let files_per_time = (create_iter * MICROSECOND) as f64 / delta_time_create;
+
+    printlninfo!(
+        "{:8}    {:9}    {:16.3}    {:16.3}",
+        fsize_b / KB as usize,
+        create_iter,
+        files_per_time,
+        delta_time_create / create_iter as f64
+    );
+
+    // delete all test files avoid Influence the next round of testing
+
+    for i in 0..create_iter {
+        let filename = format!("tmp_{}_{}.txt", fsize_b, i);
+        remove_file(filename).expect("DELETE_FILE_FAIL");
+    }
+    Ok(())
+}
+
+pub fn do_fs_delete() -> Result<(), &'static str> {
+    let fsizes_b = [1024_usize, 4096, 2 * 4096];
+
+    let overhead_ct = get_timing_overhead()?;
+
+    print_header(TRIES, FS_ITER);
+    printlninfo!("SIZE(KB)    Iteration    deleted(files/s)    time(ns/file)");
+    for fsize_b in fsizes_b.iter() {
+        do_fs_delete_inner(*fsize_b, overhead_ct)?;
+    }
+    printlninfo!("This test is equivalent to file delete in `lat_fs` in LMBench");
+    Ok(())
+}
+
+/// Internal function that actually calculates the time to delete to a file.
+/// Within the measurin section it remove the given file reference from current working directory
+/// Prior to measuring files are created and their referecnes are added to a vector
+fn do_fs_delete_inner(fsize_b: usize, overhead_ct: f64) -> Result<(), &'static str> {
+    let start_hpet_create: f64;
+    let end_hpet_create: f64;
+    let del_iter = FS_ITER;
+
+    // check if we have enough data to write. We use just const data to avoid unnecessary overhead
+    if fsize_b > WRITE_BUF_SIZE {
+        return Err("Cannot test because the file size is too big");
+    }
+
+    // delete existing files. To make sure that the file creation below succeeds.
+
+    let wbuf = &WRITE_BUF[0..fsize_b];
+
+    // Non measuring loop for file create
+    for i in 0..del_iter {
+        let filename = format!("tmp_{}_{}.txt", fsize_b, i);
+        let mut file = OpenOptions::new()
+            .read(true)
+            .write(true)
+            .create(true)
+            .open(filename)
+            .expect("Cannot create a file");
+        file.write(&wbuf).expect("Cannot write to a file");
+        drop(file);
+    }
+
+    start_hpet_create = get_timer_value()?;
+    // Measuring loop file delete
+    for i in 0..del_iter {
+        let filename = format!("tmp_{}_{}.txt", fsize_b, i);
+        remove_file(filename);
+    }
+    end_hpet_create = get_timer_value()?;
+
+    let delta_hpet_delete = end_hpet_create - start_hpet_create - overhead_ct;
+    let delta_time_delete = delta_hpet_delete;
+
+    let files_per_time = (del_iter * MICROSECOND) as f64 / delta_time_delete;
+
+    printlninfo!(
+        "{:8}    {:9}    {:16.3}    {:16.3}",
+        fsize_b / KB as usize,               // file size in KB
+        del_iter,                            // number of files
+        files_per_time,                      // files per designated time
+        delta_time_delete / del_iter as f64  // average time to delete a file
+    );
+    Ok(())
+}
diff --git a/recipes/lmbench/source/src/main.rs b/recipes/lmbench/source/src/main.rs
new file mode 100644
index 00000000..ea6c4a31
--- /dev/null
+++ b/recipes/lmbench/source/src/main.rs
@@ -0,0 +1,364 @@
+pub mod ctx;
+pub mod fs;
+pub mod mmap;
+pub mod null;
+pub mod pipe;
+
+use std::error::Error;
+use std::fs::File;
+use std::io::{BufWriter, Write};
+// extern crate libredox;
+pub const ITERATIONS: usize = 100;
+pub const TRIES: usize = 10;
+pub const T_UNIT: &str = "micro_sec";
+/// Macro for printing informational messages
+#[macro_export]
+macro_rules! printlninfo {
+    ($fmt:expr) => (println!($fmt));
+    ($fmt:expr, $($arg:tt)*) => (println!($fmt, $($arg)*));
+}
+
+/// Macro for printing warning messages
+#[macro_export]
+macro_rules! printlnwarn {
+    ($fmt:expr) => (println!($fmt));
+    ($fmt:expr, $($arg:tt)*) => (println!($fmt, $($arg)*));
+}
+
+/// Main entry point
+fn main() {
+    let mut args = std::env::args().skip(1); // 跳过程序名称
+    while let Some(arg) = args.next() {
+        match arg.as_str() {
+            "debug" => {
+                debug_test_main();
+            }
+            "null" => {
+                let _ = null::do_null();
+            }
+            "ctx" => {
+                let _ = ctx::do_ctx();
+            }
+            "bw_file_rd" => {
+                let _ = fs::do_fs_read(true);
+                let _ = fs::do_fs_read(false);
+            }
+            "lat_fs" => {
+                let _ = fs::do_fs_create_del();
+                let _ = fs::do_fs_delete();
+            }
+            "lat_pipe" => {
+                pipe::do_pipe();
+            }
+            "lat_mmap" => {
+                // 检查是否有额外参数
+                if let Some(param) = args.next() {
+                    // 尝试将参数转换为整数
+                    if let Ok(extra_param) = param.parse::<usize>() {
+                        let _ = mmap::do_memory_map(extra_param * 1024);
+                    } else {
+                        println!("Invalid parameter for lat_mmap: {}", param);
+                        std::process::exit(1);
+                    }
+                } else {
+                    // 没有额外参数时调用默认版本
+                    println!("No parameter for lat_mmap, using default:4KB mapping size");
+                    let _ = mmap::do_memory_map(4096);
+                }
+            }
+            "bw_mmap_rd" => {
+                // 获取大小参数
+                if let Some(size_arg) = args.next() {
+                    if let Ok(size_kb) = size_arg.parse::<usize>() {
+                        let size = size_kb * 1024; // 转换为字节
+                        if let Some(mode) = args.next() {
+                            match mode.as_str() {
+                                "mmap_only" => {
+                                    create_testfile("testfile", size)
+                                        .expect("Failed to create test file");
+                                    let _ = mmap::do_mmap_only(size);
+                                }
+                                "open2close" => {
+                                    create_testfile("testfile", size)
+                                        .expect("Failed to create test file");
+                                    let _ = mmap::do_open2close(size);
+                                }
+                                _ => {
+                                    println!("Invalid mode for bw_mmap_rd: {}", mode);
+                                    std::process::exit(1);
+                                }
+                            }
+                        } else {
+                            println!("No mode provided for bw_mmap_rd (expected: mmap_only or open2close)");
+                            std::process::exit(1);
+                        }
+                    } else {
+                        println!("Invalid size parameter for bw_mmap_rd: {}", size_arg);
+                        std::process::exit(1);
+                    }
+                } else {
+                    println!("No size parameter for bw_mmap_rd (expected: size in KB)");
+                    std::process::exit(1);
+                }
+            }
+            "bw_pipe" => {
+                // 获取大小参数
+                if let Some(msg_size_arg) = args.next() {
+                    if let Ok(msg_size_kb) = msg_size_arg.parse::<usize>() {
+                        let msg = msg_size_kb * 1024; // 转换为字节
+                        if let Some(total_size_arg) = args.next() {
+                            if let Ok(total_size_mb) = total_size_arg.parse::<usize>() {
+                                let total_size = total_size_mb * 1024 * 1024; // 转换为字节
+                                let _ = pipe::do_pipe_bandwidth(msg, total_size);
+                            } else {
+                                println!("Invalid size parameter for bw_pipe: {}", total_size_arg);
+                                std::process::exit(1);
+                            }
+                        } else {
+                            println!("Invalid total_size parameter for bw_pipe ");
+                            std::process::exit(1);
+                        }
+                    } else {
+                        println!("Invalid msg_size parameter for bw_pipe: {}", msg_size_arg);
+                        std::process::exit(1);
+                    }
+                } else {
+                    println!("No size parameter for bw_pipe (expected: size in KB)");
+                    std::process::exit(1);
+                }
+            }
+            _ => {
+                println!("Unknown command: {}", arg);
+            }
+        }
+    }
+}
+
+/// Debug entry function
+fn debug_test_main() {}
+
+/// Print the header of the test
+fn print_header(tries: usize, iterations: usize) {
+    printlninfo!("========================================");
+    printlninfo!("Time unit : {}", T_UNIT);
+    printlninfo!("Iterations: {}", iterations);
+    printlninfo!("Tries     : {}", tries);
+    printlninfo!("========================================");
+}
+
+/// Measures the overhead of using the timer
+fn get_timing_overhead() -> Result<f64, &'static str> {
+    const TRIES: u64 = 10;
+    let mut tries: f64 = 0.0;
+    let mut max: f64 = f64::MIN;
+    let mut min: f64 = f64::MAX;
+
+    for _ in 0..TRIES {
+        let overhead = get_timing_overhead_inner()?;
+        tries += overhead;
+        if overhead > max {
+            max = overhead;
+        }
+        if overhead < min {
+            min = overhead;
+        }
+    }
+
+    let overhead = tries / TRIES as f64;
+    printlninfo!(
+        "get_timer_value() overhead is {:.3} microseconds, original tries {:.3}",
+        overhead,
+        tries
+    );
+    Ok(overhead)
+}
+
+/// Internal function that calculates timer overhead
+fn get_timing_overhead_inner() -> Result<f64, &'static str> {
+    const ITERATIONS: usize = 10_000;
+    let start_time = get_timer_value()?;
+    let mut _tmp_time = 0.0;
+
+    for _ in 0..ITERATIONS {
+        _tmp_time = get_timer_value()?;
+    }
+    let end_time = get_timer_value()?;
+
+    let delta_time = end_time - start_time;
+    let delta_time_avg = delta_time / ITERATIONS as f64;
+
+    printlninfo!(
+        "get_timer_value() overhead is {} microseconds ({} microsecods / iteration)",
+        delta_time,
+        delta_time_avg
+    );
+
+    Ok(delta_time_avg)
+}
+
+use std::collections::BTreeMap;
+use std::fmt;
+use std::vec::Vec;
+
+pub const THRESHOLD_ERROR_RATIO: u64 = 1;
+
+use std::time::{SystemTime, UNIX_EPOCH};
+// use libc::timespec;
+// Return the mtime raw value
+pub fn get_timer_value() -> Result<f64, &'static str> {
+    match libredox::call::clock_gettime(4) {
+        Ok(ts) => {
+            let microseconds = (ts.tv_sec * 1_000_000) + (ts.tv_nsec / 1_000);
+            Ok(microseconds as f64)
+            // let nanoseconds = (ts.tv_sec * 1_000_000_000) + ts.tv_nsec;
+            // Ok(nanoseconds as u64)
+        }
+        Err(_) => {
+            println!("Error getting time");
+            Err("Error getting time")
+        }
+    }
+}
+
+pub struct Stats {
+    pub min: f64,
+    pub p_25: f64,
+    pub median: f64,
+    pub p_75: f64,
+    pub max: f64,
+    pub mode: f64,
+    pub mean: f64,
+    pub std_dev: f64,
+}
+
+impl fmt::Debug for Stats {
+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
+        write!(
+            f,
+            "Stats \n 
+        min:     {:.3} \n 
+        p_25:    {:.3} \n 
+        median:  {:.3} \n 
+        p_75:    {:.3} \n 
+        max:     {:.3} \n 
+        mode:    {:.3} \n 
+        mean:    {:.3} \n 
+        std_dev: {:.3} \n",
+            self.min,
+            self.p_25,
+            self.median,
+            self.p_75,
+            self.max,
+            self.mode,
+            self.mean,
+            self.std_dev
+        )
+    }
+}
+
+/// Helper function to calculate statistics of a provided dataset
+pub fn calculate_stats(vec: &Vec<f64>) -> Option<Stats> {
+    let mean;
+    let median;
+    let mode;
+    let p_75;
+    let p_25;
+    let min;
+    let max;
+    let var;
+    let std_dev;
+
+    if vec.is_empty() {
+        return None;
+    }
+
+    let len = vec.len();
+
+    {
+        // calculate average
+        let sum: f64 = vec.iter().sum();
+        mean = sum as f64 / len as f64;
+    }
+
+    {
+        // calculate median
+        let mut vec2 = vec.clone();
+        // vec2.sort();
+        vec2.sort_by(|a, b| a.partial_cmp(b).unwrap_or(std::cmp::Ordering::Equal));
+        let mid = len / 2;
+        let i_75 = len * 3 / 4;
+        let i_25 = len * 1 / 4;
+
+        median = vec2[mid];
+        p_25 = vec2[i_25];
+        p_75 = vec2[i_75];
+        min = vec2[0];
+        max = vec2[len - 1];
+    }
+
+    {
+        // calculate sample variance
+        let mut diff_sum: f64 = 0.0;
+        for &val in vec {
+            let x = val as f64;
+            diff_sum += (x - mean).powi(2);
+        }
+
+        var = diff_sum / len as f64;
+        std_dev = var.sqrt();
+    }
+
+    {
+        // 使用 BTreeMap
+        let mut values: BTreeMap<i64, usize> = BTreeMap::new();
+        for val in vec {
+            let key = (val * 100.0) as i64; // 将浮点数放大并转换为整数
+            values.entry(key).and_modify(|v| *v += 1).or_insert(1);
+        }
+
+        // 计算众数
+        let tmp = *values
+            .iter()
+            .max_by(|(_k1, v1), (_k2, v2)| v1.cmp(v2))
+            .unwrap()
+            .0;
+
+        // 转换回浮点数
+        mode = tmp as f64 / 100.0;
+    }
+
+    Some(Stats {
+        min,
+        p_25,
+        median,
+        p_75,
+        max,
+        mode,
+        mean,
+        std_dev,
+    })
+}
+
+pub fn create_testfile(filename: &str, size: usize) -> Result<(), Box<dyn Error>> {
+    // 打开文件（如果存在会覆盖）
+    let file = File::create(filename)?;
+    let mut writer = BufWriter::new(file);
+
+    // 向文件写入指定大小的数据
+    let buffer = vec![0u8; 1024 * 1024]; // 1MB 的缓冲区
+    let mut remaining = size;
+
+    while remaining > 0 {
+        let write_size = if remaining >= buffer.len() {
+            buffer.len()
+        } else {
+            remaining
+        };
+        writer.write_all(&buffer[..write_size])?;
+        remaining -= write_size;
+    }
+
+    writer.flush()?;
+    printlninfo!("Test file '{}' created with size {} bytes.", filename, size);
+    Ok(())
+}
diff --git a/recipes/lmbench/source/src/mmap.rs b/recipes/lmbench/source/src/mmap.rs
new file mode 100644
index 00000000..1735d97a
--- /dev/null
+++ b/recipes/lmbench/source/src/mmap.rs
@@ -0,0 +1,318 @@
+use crate::*;
+use libc::{
+    close, mmap, munmap, open, MAP_ANONYMOUS, MAP_PRIVATE, MAP_SHARED, O_RDONLY, PROT_READ,
+    PROT_WRITE,
+};
+
+use std::ffi::CString;
+use std::ptr;
+
+const MMAP_ITER: usize = ITERATIONS * 100;
+/// Measures the time to create and destroy a mapping.
+/// Calls `do_memory_map_inner` multiple times to perform the actual operation
+pub fn do_memory_map(size: usize) -> Result<(), &'static str> {
+    let mut tries: f64 = 0.0;
+    let mut max: f64 = core::f64::MIN;
+    let mut min: f64 = core::f64::MAX;
+    let mut vec = Vec::with_capacity(TRIES);
+
+    let overhead_ct = get_timing_overhead()?;
+    print_header(TRIES, MMAP_ITER);
+
+    for i in 0..TRIES {
+        let lat = do_memory_map_inner(overhead_ct, i + 1, TRIES, size)?;
+
+        tries += lat;
+        vec.push(lat);
+
+        if lat > max {
+            max = lat;
+        }
+        if lat < min {
+            min = lat;
+        }
+    }
+
+    let lat = tries / TRIES as f64;
+    // We expect the maximum and minimum to be within 10*THRESHOLD_ERROR_RATIO % of the mean value
+    let err = (lat * 10.0 * THRESHOLD_ERROR_RATIO as f64) / 100.0;
+    if max - lat > err || lat - min > err {
+        printlnwarn!(
+            "memory_map_test diff is too big: {:.3} ({:.3} - {:.3}) {}",
+            max - min,
+            max,
+            min,
+            T_UNIT
+        );
+    }
+    let stats = calculate_stats(&vec).ok_or("couldn't calculate stats")?;
+
+    printlninfo!("MEMORY MAP result: ({})", T_UNIT);
+    printlninfo!("{:?}", stats);
+    printlninfo!("This test is equivalent to `lat_mmap` in LMBench");
+    Ok(())
+}
+
+/// Internal function that actually calculates the time to create and destroy a memory mapping.
+/// Measures this by continually allocating and dropping `MappedPages`.
+fn do_memory_map_inner(
+    overhead_ct: f64,
+    th: usize,
+    nr: usize,
+    mapsize: usize,
+) -> Result<f64, &'static str> {
+    let MAPPING_SIZE: usize = mapsize;
+
+    let start_hpet: f64;
+    let end_hpet: f64;
+    let delta_hpet: f64;
+
+    start_hpet = get_timer_value()?;
+    for _ in 0..MMAP_ITER {
+        // 调用 mmap 映射一块内存
+        let addr = unsafe {
+            mmap(
+                ptr::null_mut(),
+                MAPPING_SIZE,
+                PROT_READ | PROT_WRITE,
+                MAP_ANONYMOUS | MAP_PRIVATE,
+                -1,
+                0,
+            )
+        };
+
+        unsafe {
+            let data = addr as *mut u8;
+            *data = 0xFF; // 写入一个字节
+        }
+
+        // 调用 munmap 解除映射
+        let result = unsafe { munmap(addr, MAPPING_SIZE) };
+    }
+
+    end_hpet = get_timer_value()?;
+
+    delta_hpet = end_hpet - start_hpet - overhead_ct;
+    let delta_time = delta_hpet;
+    let delta_time_avg = delta_time / MMAP_ITER as f64;
+    printlninfo!(
+        "memory_map_test_inner ({}/{}): hpet {:.3} , overhead {:.3}, {:.3} total_time -> {:.3} {}",
+        th,
+        nr,
+        delta_hpet,
+        overhead_ct,
+        delta_time,
+        delta_time_avg,
+        T_UNIT
+    );
+
+    Ok(delta_time_avg)
+}
+
+/// mmap_only 测试
+pub fn do_mmap_only(size: usize) -> Result<(), &'static str> {
+    let mut tries: f64 = 0.0;
+    let mut max: f64 = core::f64::MIN;
+    let mut min: f64 = core::f64::MAX;
+    let mut vec = Vec::with_capacity(TRIES);
+
+    let overhead_ct = get_timing_overhead()?;
+    print_header(TRIES, MMAP_ITER);
+
+    for i in 0..TRIES {
+        let lat = do_mmap_only_inner(overhead_ct, i + 1, TRIES, size)?;
+        tries += lat;
+        vec.push(lat);
+
+        if lat > max {
+            max = lat;
+        }
+        if lat < min {
+            min = lat;
+        }
+    }
+
+    let lat = tries / TRIES as f64;
+    let err = (lat * 10.0 * THRESHOLD_ERROR_RATIO as f64) / 100.0;
+    if max - lat > err || lat - min > err {
+        printlnwarn!(
+            "mmap_only_test diff is too big: {:.3} ({:.3} - {:.3}) {}",
+            max - min,
+            max,
+            min,
+            T_UNIT
+        );
+    }
+    let stats = calculate_stats(&vec).ok_or("couldn't calculate stats")?;
+
+    printlninfo!("MMAP_ONLY result: ({})", T_UNIT);
+    printlninfo!("{:?}", stats);
+    Ok(())
+}
+
+fn do_mmap_only_inner(
+    overhead_ct: f64,
+    th: usize,
+    nr: usize,
+    size: usize,
+) -> Result<f64, &'static str> {
+    let filename = "testfile"; // 替换为你的测试文件路径
+    let c_filename = CString::new(filename).expect("CString::new failed");
+
+    // 打开文件
+    let fd = unsafe { open(c_filename.as_ptr(), O_RDONLY) };
+    if fd < 0 {
+        return Err("Failed to open file");
+    }
+
+    let start_hpet = get_timer_value()?;
+
+    for _ in 0..ITERATIONS {
+        // mmap 文件内容
+        let addr = unsafe { mmap(ptr::null_mut(), size, PROT_READ, MAP_SHARED, fd, 0) };
+
+        if addr == libc::MAP_FAILED {
+            unsafe { close(fd) };
+            return Err("Failed to mmap file");
+        }
+
+        // 模拟读取
+        unsafe {
+            let data = addr as *const u8;
+            for i in 0..size {
+                let _ = *data.offset(i as isize); // 逐字节读取
+            }
+        }
+
+        // 解除映射
+        let result = unsafe { munmap(addr, size) };
+        if result != 0 {
+            unsafe { close(fd) };
+            return Err("Failed to munmap");
+        }
+    }
+
+    let end_hpet = get_timer_value()?;
+    unsafe { close(fd) };
+
+    let delta_hpet = end_hpet - start_hpet - overhead_ct;
+    let delta_time_avg = delta_hpet / ITERATIONS as f64;
+
+    printlninfo!(
+        "mmap_only_test_inner ({}/{}): hpet {:.3}, overhead {:.3}, {:.3} total_time -> {:.3} {}",
+        th,
+        nr,
+        delta_hpet,
+        overhead_ct,
+        delta_hpet,
+        delta_time_avg,
+        T_UNIT
+    );
+
+    Ok(delta_time_avg)
+}
+
+/// open2close 测试
+pub fn do_open2close(size: usize) -> Result<(), &'static str> {
+    let mut tries: f64 = 0.0;
+    let mut max: f64 = core::f64::MIN;
+    let mut min: f64 = core::f64::MAX;
+    let mut vec = Vec::with_capacity(TRIES);
+
+    let overhead_ct = get_timing_overhead()?;
+    print_header(TRIES, MMAP_ITER);
+
+    for i in 0..TRIES {
+        let lat = do_open2close_inner(overhead_ct, i + 1, TRIES, size)?;
+        tries += lat;
+        vec.push(lat);
+
+        if lat > max {
+            max = lat;
+        }
+        if lat < min {
+            min = lat;
+        }
+    }
+
+    let lat = tries / TRIES as f64;
+    let err = (lat * 10.0 * THRESHOLD_ERROR_RATIO as f64) / 100.0;
+    if max - lat > err || lat - min > err {
+        printlnwarn!(
+            "open2close_test diff is too big: {:.3} ({:.3} - {:.3}) {}",
+            max - min,
+            max,
+            min,
+            T_UNIT
+        );
+    }
+    let stats = calculate_stats(&vec).ok_or("couldn't calculate stats")?;
+
+    printlninfo!("OPEN2CLOSE result: ({})", T_UNIT);
+    printlninfo!("{:?}", stats);
+    Ok(())
+}
+
+fn do_open2close_inner(
+    overhead_ct: f64,
+    th: usize,
+    nr: usize,
+    size: usize,
+) -> Result<f64, &'static str> {
+    let filename = "testfile"; // 替换为你的测试文件路径
+    let c_filename = CString::new(filename).expect("CString::new failed");
+
+    let start_hpet = get_timer_value()?;
+
+    for _ in 0..ITERATIONS {
+        // 打开文件
+        let fd = unsafe { open(c_filename.as_ptr(), O_RDONLY) };
+        if fd < 0 {
+            return Err("Failed to open file");
+        }
+
+        // mmap 文件内容
+        let addr = unsafe { mmap(ptr::null_mut(), size, PROT_READ, MAP_SHARED, fd, 0) };
+
+        if addr == libc::MAP_FAILED {
+            unsafe { close(fd) };
+            return Err("Failed to mmap file");
+        }
+
+        // 模拟读取
+        unsafe {
+            let data = addr as *const u8;
+            for i in 0..size {
+                let _ = *data.offset(i as isize); // 逐字节读取
+            }
+        }
+
+        // 解除映射
+        let result = unsafe { munmap(addr, size) };
+        if result != 0 {
+            unsafe { close(fd) };
+            return Err("Failed to munmap");
+        }
+
+        // 关闭文件
+        unsafe { close(fd) };
+    }
+
+    let end_hpet = get_timer_value()?;
+
+    let delta_hpet = end_hpet - start_hpet - overhead_ct;
+    let delta_time_avg = delta_hpet / ITERATIONS as f64;
+
+    printlninfo!(
+        "open2close_test_inner ({}/{}): hpet {:.3}, overhead {:.3}, {:.3} total_time -> {:.3} {}",
+        th,
+        nr,
+        delta_hpet,
+        overhead_ct,
+        delta_hpet,
+        delta_time_avg,
+        T_UNIT
+    );
+
+    Ok(delta_time_avg)
+}
diff --git a/recipes/lmbench/source/src/null.rs b/recipes/lmbench/source/src/null.rs
new file mode 100644
index 00000000..a1e09283
--- /dev/null
+++ b/recipes/lmbench/source/src/null.rs
@@ -0,0 +1,82 @@
+/// Perform null syscall benchmark
+use crate::*;
+
+pub fn do_null() -> Result<(), &'static str> {
+    let mut tries: f64 = 0.0;
+    let mut max: f64 = f64::MIN;
+    let mut min: f64 = f64::MAX;
+    let mut vec = Vec::with_capacity(TRIES);
+
+    let overhead_ct = get_timing_overhead()?;
+    print_header(TRIES, ITERATIONS * 1_000);
+
+    for i in 0..TRIES {
+        let lat = do_null_inner(overhead_ct, i + 1, TRIES)?;
+
+        tries += lat;
+        vec.push(lat);
+
+        if lat > max {
+            max = lat;
+        }
+        if lat < min {
+            min = lat;
+        }
+    }
+
+    let lat = tries / TRIES as f64;
+    let err = (lat * 10.0) / 100.0; // Allowable error margin
+    if max - lat > err || lat - min > err {
+        printlnwarn!(
+            "null_test diff is too big: {:.3} ({:.3} - {:.3}) {}",
+            max - min,
+            max,
+            min,
+            T_UNIT
+        );
+    }
+
+    printlninfo!("Null syscall test completed successfully.");
+    let stats = calculate_stats(&vec).ok_or("couldn't calculate stats")?;
+
+    printlninfo!("{:?}", stats);
+    printlninfo!("This test is equivalent to `lat_syscall null` in LMBench");
+    Ok(())
+}
+
+/// Internal function that actually calculates the time for null syscall.
+/// Measures this by calling `libredox::call::getpid()` of the current task.
+fn do_null_inner(overhead_ct: f64, th: usize, nr: usize) -> Result<f64, &'static str> {
+    let start_hpet = get_timer_value()? as f64;
+    let mut end_hpet: f64;
+
+    let tmp_iterations = ITERATIONS * 1_000;
+    for _ in 0..tmp_iterations {
+        let _mypid = libredox::call::getpid();
+    }
+    end_hpet = get_timer_value()? as f64;
+
+    let mut delta_hpet = end_hpet - start_hpet;
+    if delta_hpet < overhead_ct {
+        printlnwarn!(
+            "Ignore overhead for null because overhead({}) > diff({})",
+            overhead_ct,
+            delta_hpet
+        );
+    } else {
+        delta_hpet -= overhead_ct;
+    }
+
+    let delta_time_avg = delta_hpet / (tmp_iterations as f64);
+
+    printlninfo!(
+        "null_test_inner ({}/{}): overhead {:.3}, {:.3} total_time -> {:.3}",
+        th,
+        nr,
+        overhead_ct,
+        delta_hpet,
+        delta_time_avg
+    );
+
+    Ok(delta_time_avg)
+}
diff --git a/recipes/lmbench/source/src/pipe.rs b/recipes/lmbench/source/src/pipe.rs
new file mode 100644
index 00000000..46634119
--- /dev/null
+++ b/recipes/lmbench/source/src/pipe.rs
@@ -0,0 +1,304 @@
+use crate::*;
+use nix::unistd::{close, fork, pipe, ForkResult};
+use std::fs::File;
+use std::io::{Read, Write};
+use std::os::unix::io::FromRawFd;
+use std::process::Command;
+use std::time::Instant;
+
+const PIPE_ITER: usize = ITERATIONS * 100; // 测试循环次数
+
+pub fn do_pipe() -> Result<(), &'static str> {
+    // 创建两个管道
+
+    let mut tries: f64 = 0.0;
+    let mut max: f64 = core::f64::MIN;
+    let mut min: f64 = core::f64::MAX;
+    let mut vec = Vec::with_capacity(TRIES);
+    let mut lat = 0.0;
+
+    let overhead_ct = get_timing_overhead()?;
+    print_header(TRIES, PIPE_ITER);
+
+    for i in 0..TRIES {
+        let (p1_read, p1_write) = create_pipe();
+        let (p2_read, p2_write) = create_pipe();
+        // 创建子进程
+        match unsafe { fork() } {
+            Ok(ForkResult::Child) => {
+                // 子进程: 关闭父进程使用的管道端
+                close(p1_write).unwrap();
+                close(p2_read).unwrap();
+
+                // 子进程运行 writer
+                writer(p1_read, p2_write);
+
+                // 退出子进程
+                std::process::exit(0);
+            }
+            Ok(ForkResult::Parent { child }) => {
+                // 父进程: 关闭子进程使用的管道端
+                close(p1_read).unwrap();
+                close(p2_write).unwrap();
+
+                // 测试通信延迟
+                lat = measure_latency(overhead_ct, i + 1, TRIES, p1_write, p2_read, PIPE_ITER)?;
+
+                // 清理子进程
+                Command::new("kill")
+                    .arg("-9")
+                    .arg(format!("{}", nix::unistd::getpid()))
+                    .output()
+                    .unwrap();
+            }
+            Err(err) => {
+                eprintln!("Fork failed: {}", err);
+                std::process::exit(1);
+            }
+        }
+
+        tries += lat;
+        vec.push(lat);
+
+        if lat > max {
+            max = lat;
+        }
+        if lat < min {
+            min = lat;
+        }
+    }
+
+    let lat = tries / TRIES as f64;
+    // We expect the maximum and minimum to be within 10*THRESHOLD_ERROR_RATIO % of the mean value
+    let err = (lat * 10.0 * THRESHOLD_ERROR_RATIO as f64) / 100.0;
+    if max - lat > err || lat - min > err {
+        printlnwarn!(
+            "lat_pipe_test diff is too big: {:.3} ({:.3} - {:.3}) {}",
+            max - min,
+            max,
+            min,
+            T_UNIT
+        );
+    }
+    let stats = calculate_stats(&vec)
+        .ok_or("couldn't calculate stats")
+        .unwrap();
+
+    printlninfo!("LAT_PIPE result: ({})", T_UNIT);
+    printlninfo!("{:?}", stats);
+    printlninfo!("This test is equivalent to `lat_pipe` in LMBench");
+    Ok(())
+}
+
+// 创建管道
+fn create_pipe() -> (i32, i32) {
+    let (read_fd, write_fd) = pipe().expect("Failed to create pipe");
+    (read_fd, write_fd)
+}
+
+// 测量管道通信延迟
+fn measure_latency(
+    overhead_ct: f64,
+    th: usize,
+    nr: usize,
+    write_fd: i32,
+    read_fd: i32,
+    iterations: usize,
+) -> Result<f64, &'static str> {
+    let mut dummy_sum = 0;
+    let mut buf = [0u8; 1]; // 单字节缓冲区
+
+    // 打开文件描述符为 Rust 标准库的 File
+    let mut writer = unsafe { File::from_raw_fd(write_fd) };
+    let mut reader = unsafe { File::from_raw_fd(read_fd) };
+
+    // 记录起始时间
+    let start_hpet = get_timer_value()?;
+
+    for _ in 0..iterations {
+        // 父进程写数据到 p1
+        writer.write_all(&buf).expect("Failed to write to pipe");
+        writer.flush().unwrap();
+
+        // 父进程从 p2 读取数据
+        reader
+            .read_exact(&mut buf)
+            .expect("Failed to read from pipe");
+        dummy_sum += buf[0] as u64;
+    }
+
+    // 记录结束时间
+    let end_hpet = get_timer_value()?;
+    let delta_hpet = end_hpet - start_hpet - overhead_ct;
+    let delta_time = delta_hpet;
+    let delta_time_avg = delta_time / PIPE_ITER as f64;
+
+    printlninfo!(
+        "memory_map_test_inner ({}/{}): hpet {:.3} , overhead {:.3}, {:.3} total_time -> {:.3} {}",
+        th,
+        nr,
+        delta_hpet,
+        overhead_ct,
+        delta_time,
+        delta_time_avg,
+        T_UNIT
+    );
+
+    Ok(delta_time_avg)
+}
+
+// 子进程逻辑
+fn writer(read_fd: i32, write_fd: i32) {
+    let mut buf = [0u8; 1];
+    let mut reader = unsafe { File::from_raw_fd(read_fd) };
+    let mut writer = unsafe { File::from_raw_fd(write_fd) };
+
+    loop {
+        match reader.read_exact(&mut buf) {
+            Ok(_) => {
+                writer.write_all(&buf).expect("Failed to write to pipe");
+            }
+            Err(e) if e.kind() == std::io::ErrorKind::UnexpectedEof => {
+                println!("Writer detected EOF, exiting...");
+                break;
+            }
+            Err(e) => {
+                panic!("Unexpected error: {:?}", e);
+            }
+        }
+    }
+}
+
+pub fn do_pipe_bandwidth(packet_size: usize, total_size: usize) -> Result<(), &'static str> {
+    let mut tries: f64 = 0.0;
+    let mut max: f64 = core::f64::MIN;
+    let mut min: f64 = core::f64::MAX;
+    let mut vec = Vec::with_capacity(TRIES);
+
+    let overhead_ct = get_timing_overhead()?;
+    print_header(TRIES, PIPE_ITER);
+
+    for i in 0..TRIES {
+        let bandwidth = measure_bandwidth(overhead_ct, i + 1, TRIES, packet_size, total_size)?;
+        tries += bandwidth;
+        vec.push(bandwidth);
+
+        if bandwidth > max {
+            max = bandwidth;
+        }
+        if bandwidth < min {
+            min = bandwidth;
+        }
+    }
+
+    let avg_bandwidth = tries / TRIES as f64;
+    let err = (avg_bandwidth * 10.0 * THRESHOLD_ERROR_RATIO as f64) / 100.0;
+
+    if max - avg_bandwidth > err || avg_bandwidth - min > err {
+        printlnwarn!(
+            "bw_pipe_test diff is too big: {:.3} ({:.3} - {:.3}) {}",
+            max - min,
+            max,
+            min,
+            T_UNIT
+        );
+    }
+
+    let stats = calculate_stats(&vec).ok_or("couldn't calculate stats")?;
+    printlninfo!("BW_PIPE result: ({})", T_UNIT);
+    printlninfo!("{:?}", stats);
+    let microseconds_in_one_second = 1_000_000.0; // 10^6
+    let bytes_in_one_mb = 2_f64.powi(20);         // 2^20
+    // Convert bytes/us to MB/s
+    let mb_per_s = (avg_bandwidth * microseconds_in_one_second) / bytes_in_one_mb;
+    printlninfo!("Average bandwidth: {:.3}MB / sec", mb_per_s );
+    printlninfo!("This test is equivalent to `bw_pipe` in LMBench");
+    Ok(())
+}
+
+fn measure_bandwidth(
+    overhead_ct: f64,
+    th: usize,
+    nr: usize,
+    packet_size: usize,
+    total_size: usize,
+) -> Result<f64, &'static str> {
+    let mut buf = vec![0u8; packet_size];
+    let mut total_transferred = 0;
+
+    // 创建管道
+    let (read_fd, write_fd) = create_pipe();
+
+    match unsafe { fork() } {
+        Ok(ForkResult::Child) => {
+            // 子进程: 关闭读取端
+            close(read_fd).unwrap();
+
+            let mut writer = unsafe { File::from_raw_fd(write_fd) };
+            loop {
+                match writer.write(&buf) {
+                    Ok(written) => {
+                        if written == 0 {
+                            break; // 写入结束，退出循环
+                        }
+                    }
+                    Err(e) if e.kind() == std::io::ErrorKind::BrokenPipe => {
+                        // 遇到 BrokenPipe 错误，正常退出循环
+                        break;
+                    }
+                    Err(e) => {
+                        // 对其他错误的处理，保持程序稳定
+                        eprintln!("Unexpected error during write: {:?}", e);
+                        break;
+                    }
+                }
+            }
+            std::process::exit(0);
+        }
+        Ok(ForkResult::Parent { child }) => {
+            // 父进程: 关闭写入端
+            close(write_fd).unwrap();
+
+            // 父进程读取数据
+            let mut reader = unsafe { File::from_raw_fd(read_fd) };
+            let start_time = get_timer_value()?;
+
+            while total_transferred < total_size {
+                let read = reader.read(&mut buf).expect("Read from pipe failed");
+                if read == 0 {
+                    break;
+                }
+                total_transferred += read;
+            }
+
+            let end_time = get_timer_value()?;
+            close(read_fd).unwrap();
+
+            // 清理子进程
+            Command::new("kill")
+                .arg("-9")
+                .arg(format!("{}", child))
+                .output()
+                .unwrap();
+
+            let elapsed_time = end_time - start_time - overhead_ct;
+            let bandwidth = total_size as f64 / elapsed_time; // 以字节每时间单位衡量带宽
+
+            printlninfo!(
+                "bw_pipe_test_inner ({}/{}): total_bytes: {}, time: {:.3}, bandwidth: {:.3} bytes/{}",
+                th,
+                nr,
+                total_transferred,
+                elapsed_time,
+                bandwidth,
+                T_UNIT
+            );
+
+            Ok(bandwidth)
+        }
+        Err(err) => {
+            eprintln!("Fork failed: {}", err);
+            std::process::exit(1);
+        }
+    }
+}
